Index: sysproc.c
===================================================================
--- sysproc.c	(revision 3)
+++ sysproc.c	(working copy)
@@ -26,6 +26,22 @@
 }
 
 int
+sys_wait2(void)
+{
+  char* wtime;
+  char* rtime;
+  argptr(0,&wtime,sizeof(wtime));
+  argptr(1,&rtime,sizeof(rtime));
+  return wait2((int*)wtime,(int*)rtime);
+}
+
+int
+sys_nice(void)
+{
+  return nice();
+}
+
+int
 sys_kill(void)
 {
   int pid;
Index: proc.c
===================================================================
--- proc.c	(revision 3)
+++ proc.c	(working copy)
@@ -6,7 +6,14 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "limits.h"
 
+//for queue
+#define NULL 0
+#define SIZE_OF_QUEUE 64
+
+
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -20,6 +27,8 @@
 
 static void wakeup1(void *chan);
 
+
+
 void
 pinit(void)
 {
@@ -27,7 +36,7 @@
 }
 
 //PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
+// Look in the process table for an UNUSED proc.f
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
@@ -69,7 +78,13 @@
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
-
+  //update p->ctime
+  acquire(&tickslock);
+  p->ctime = ticks;
+  p->ptime = p->ctime;
+  release(&tickslock);
+  //update priority to HIGH by default
+  p->priority = HIGH;
   return p;
 }
 
@@ -98,8 +113,8 @@
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
+  p->state = RUNNABLE;
 
-  p->state = RUNNABLE;
 }
 
 // Grow current process's memory by n bytes.
@@ -156,7 +171,9 @@
  
   pid = np->pid;
   np->state = RUNNABLE;
+
   safestrcpy(np->name, proc->name, sizeof(proc->name));
+  
   return pid;
 }
 
@@ -192,13 +209,21 @@
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->parent == proc){
       p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
+      if(p->state == ZOMBIE){
+        wakeup1(initproc);		
+      }
     }
   }
 
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
+  
+  //update p->etime
+  
+  acquire(&tickslock);
+  proc->etime = ticks;
+  release(&tickslock);
+ 
   sched();
   panic("zombie exit");
 }
@@ -246,6 +271,63 @@
   }
 }
 
+int wait2(int* wtime, int* rtime){
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+	*wtime = (p->etime - p->ctime) - p->rtime;
+	*rtime = p->rtime;
+	p->etime = 0;
+	p->ctime = 0;
+	p->rtime = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+//Each call to nice() reduces the priority of the current process by one level:
+// - from High to Medium, from Medium to Low.
+int nice(){
+  if(proc->priority == HIGH){
+      proc->priority = MEDIUM;
+      return 0;
+  }
+  if(proc->priority == MEDIUM){
+      proc->priority = LOW;
+      return 0;
+  }
+  return -1;
+}
+
 void
 register_handler(sighandler_t sighandler)
 {
@@ -262,6 +344,16 @@
   proc->tf->eip = (uint)sighandler;
 }
 
+// Check if the queue of a certain priority (LOW, MEDIUM, HIGH) is empty.
+// return 1 if empty else 0 
+int empty_queue(int priority){
+  struct proc* p;
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->priority == priority && (p->state == RUNNABLE || p->state == RUNNING))
+	return 0;
+  }
+  return 1;
+}
 
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
@@ -275,20 +367,58 @@
 scheduler(void)
 {
   struct proc *p;
-
+  //struct proc *ptest;
+  struct proc * proc_temp;
+  int min_time=INT_MAX;
+  double min_ratio=INT_MAX;
+  double ratio_temp = INT_MAX;
+  int found_proc;
   for(;;){
+    
     // Enable interrupts on this processor.
     sti();
-
+    
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
+    if(SCHEDFLAG == _RR){
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
 
+	//if current process is not first do nothing
+	
+	if(p->state != RUNNABLE)
+	  continue;
+
+	// Switch to chosen process.  It is the process's job
+	// to release ptable.lock and then reacquire it
+	// before jumping back to us.
+
+	proc = p;
+	switchuvm(p);
+	p->state = RUNNING;
+	swtch(&cpu->scheduler, proc->context);
+	switchkvm();
+
+	// Process is done running for now.
+	// It should have changed its p->state before coming back.
+	proc = 0;
+      }
+    }
+    if(SCHEDFLAG == _FRR){
+      min_time = INT_MAX;
+	// find min process which runnable to run
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	if(p->ptime < min_time && p->state == RUNNABLE){
+	  proc_temp = p;
+	  min_time = p->ptime;
+	}
+      }
+      
+      //if current process is not first do nothing
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
+      
+      p=proc_temp;
       proc = p;
       switchuvm(p);
       p->state = RUNNING;
@@ -298,9 +428,140 @@
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       proc = 0;
+      
     }
+    if(SCHEDFLAG == _GRT){
+      min_ratio = INT_MAX;
+      
+	// find min process which runnable to run
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	 if(min_ratio==0)
+	  min_ratio=INT_MAX;
+	  
+	
+	//calculate min_ratio
+	  acquire(&tickslock);
+	if(ticks != p->ctime){
+	  ratio_temp = ((double)(p->rtime))/((double)(ticks - p->ctime));
+	  
+	  if(ratio_temp < min_ratio && p->state == RUNNABLE){
+	    proc_temp = p;
+	    min_ratio = ratio_temp;
+	    
+	 }
+	}
+	   release(&tickslock);
+      }
+      
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+  
+      p=proc_temp;
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+      
+    }
+    if(SCHEDFLAG == _3Q){
+      found_proc = 0;
+  
+      // Take process from HIGH priority queue
+      if(!empty_queue(HIGH)){
+	min_ratio = INT_MAX;
+	 for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	  
+	  if(min_ratio==0)
+	    min_ratio=INT_MAX;
+	    
+	  if(p->priority != HIGH)
+	    continue;
+	   
+	  //calculate min_ratio
+	  acquire(&tickslock);
+	  if(ticks != p->ctime){
+	    ratio_temp = ((double)(p->rtime))/((double)(ticks - p->ctime));
+	    if(ratio_temp < min_ratio && p->state == RUNNABLE && p->priority == HIGH){
+	      proc_temp = p;
+	      min_ratio = ratio_temp;
+	      //cprintf("--Waste Time--\n");
+	    }
+	    
+	  }
+	  found_proc = 1;
+	  release(&tickslock);
+	 
+	}
+      }
+      
+      // Take process from MEDIUM priority queue
+      if(found_proc == 0 && !empty_queue(MEDIUM)){
+	min_time = INT_MAX;
+	// find min process which runnable to run
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	  
+	  if(p->ptime < min_time && p->state == RUNNABLE && p->priority == MEDIUM){
+	    proc_temp = p;
+	    min_time = p->ptime;
+	    
+	  }
+	}
+	found_proc = 1;
+      }
+      // Take process from LOW priority queue
+      if(found_proc == 0 && !empty_queue(LOW)){
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+
+	  //if current process is not first do nothing
+	  
+	  if(p->state != RUNNABLE || p->priority != LOW)
+	    continue;
+	  
+	  proc_temp = p;
+	  //break;
+	  
+	  // Switch to chosen process.  It is the process's job
+	  // to release ptable.lock and then reacquire it
+	  // before jumping back to us.
+	  
+	  p=proc_temp;
+	  proc = p;
+	  switchuvm(p);
+	  p->state = RUNNING;
+	  swtch(&cpu->scheduler, proc->context);
+	  switchkvm();
+
+	  // Process is done running for now.
+	  // It should have changed its p->state before coming back.
+	  proc = 0;
+	}
+	release(&ptable.lock);
+	continue;
+      }
+      
+   
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      
+      p=proc_temp;
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    }
     release(&ptable.lock);
-
   }
 }
 
@@ -320,6 +581,7 @@
   if(readeflags()&FL_IF)
     panic("sched interruptible");
   intena = cpu->intena;
+
   swtch(&proc->context, cpu->scheduler);
   cpu->intena = intena;
 }
@@ -330,6 +592,12 @@
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   proc->state = RUNNABLE;
+  
+  //update proc->ptime
+  acquire(&tickslock);
+  proc->ptime = ticks;
+  release(&tickslock);
+  
   sched();
   release(&ptable.lock);
 }
@@ -352,6 +620,7 @@
   }
   
   // Return to "caller", actually trapret (see allocproc).
+  
 }
 
 // Atomically release lock and sleep on chan.
@@ -379,8 +648,8 @@
   // Go to sleep.
   proc->chan = chan;
   proc->state = SLEEPING;
+  
   sched();
-
   // Tidy up.
   proc->chan = 0;
 
@@ -400,8 +669,9 @@
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    if(p->state == SLEEPING && p->chan == chan){
+      p->state = RUNNABLE;     
+    }
 }
 
 // Wake up all processes sleeping on chan.
@@ -426,8 +696,10 @@
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING){
         p->state = RUNNABLE;
+
+      }
       release(&ptable.lock);
       return 0;
     }
@@ -471,6 +743,4 @@
     }
     cprintf("\n");
   }
-}
-
-
+}
\ No newline at end of file
Index: trap.c
===================================================================
--- trap.c	(revision 3)
+++ trap.c	(working copy)
@@ -8,6 +8,7 @@
 #include "traps.h"
 #include "spinlock.h"
 
+
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
@@ -51,6 +52,11 @@
     if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
+      //update proc->rtime
+      if(proc != 0){
+	 if(proc->state == RUNNING)
+	    proc->rtime++;
+      }
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -85,6 +91,7 @@
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpu->id, tf->eip, rcr2());
       panic("trap");
+      
     }
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
@@ -102,8 +109,14 @@
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+    if(SCHEDFLAG == _RR || SCHEDFLAG == _FRR || (SCHEDFLAG == _3Q && (proc->priority == MEDIUM || proc->priority == LOW))){  //added for round robin scheduling policy
+      if((proc->rtime % QUANTA) == 0)
+	  yield();
+    }else{
+      yield();
+    }
+  }
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
Index: proc.h
===================================================================
--- proc.h	(revision 3)
+++ proc.h	(working copy)
@@ -51,6 +51,8 @@
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+enum procpriority { LOW, MEDIUM, HIGH };
+
 typedef void (*sighandler_t)(void);
 
 // Per-process state
@@ -59,6 +61,11 @@
   pde_t* pgdir;                // Page table
   char *kstack;                // Bottom of kernel stack for this process
   enum procstate state;        // Process state
+  enum procpriority priority;	// Process priority
+  uint ctime;			// Creation time
+  uint etime;			// End time
+  uint rtime;			// Total running time
+  uint ptime;			// Last time process ran (for FRR policy)
   volatile int pid;            // Process ID
   struct proc *parent;         // Parent process
   struct trapframe *tf;        // Trap frame for current syscall
Index: defs.h
===================================================================
--- defs.h	(revision 3)
+++ defs.h	(working copy)
@@ -116,6 +116,8 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int 		wait2(int* wtime, int* rtime);
+int		nice(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
Index: console.c
===================================================================
--- console.c	(revision 3)
+++ console.c	(working copy)
@@ -14,6 +14,8 @@
 #include "proc.h"
 #include "x86.h"
 
+
+
 static void consputc(int);
 
 static int panicked = 0;
@@ -124,6 +126,8 @@
 //PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
+#define LEFTARROW 0xE4
+#define RIGHTARROW 0xE5
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
 static void
@@ -140,8 +144,18 @@
   if(c == '\n')
     pos += 80 - pos%80;
   else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
+    if(pos > 0){
+      --pos;
+      
+      crt[pos] = ' ' | 0x0700;
+    }
+  } else if(c == LEFTARROW){
+      if(pos > 0) {
+	--pos;
+      }
+    }else if(c == RIGHTARROW){
+	++pos;
+      }else
     crt[pos++] = (c&0xff) | 0x0700;  // black on white
   
   if((pos/80) >= 24){  // Scroll up.
@@ -154,7 +168,10 @@
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
   outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
+  /*
+  if(c == BACKSPACE)
+    crt[pos] = ' ' | 0x0700;
+  */
 }
 
 void
@@ -168,7 +185,11 @@
 
   if(c == BACKSPACE){
     uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
+    } else if(c == LEFTARROW){
+	    uartputc('\b');
+      }else if(c == RIGHTARROW){
+	  uartputc('\x1b'); uartputc('['); uartputc('1'); uartputc('C');
+	}else
     uartputc(c);
   cgaputc(c);
 }
@@ -180,6 +201,7 @@
   uint r;  // Read index
   uint w;  // Write index
   uint e;  // Edit index
+  uint x;  // Cursor index 
 } input;
 
 #define C(x)  ((x)-'@')  // Control-x
@@ -188,7 +210,7 @@
 consoleintr(int (*getc)(void))
 {
   int c;
-
+  
   acquire(&input.lock);
   while((c = getc()) >= 0){
     switch(c){
@@ -198,22 +220,73 @@
     case C('U'):  // Kill line.
       while(input.e != input.w &&
             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+	input.x--;
         input.e--;
         consputc(BACKSPACE);
       }
       break;
     case C('H'): case '\x7f':  // Backspace
       if(input.e != input.w){
+	input.x--;
         input.e--;
         consputc(BACKSPACE);
+	 /* if we use BACKSPACE in the middle of a line*/ 
+	 if(input.e != input.x){
+	      /*shift all chars*/
+	    uint j = input.x;
+	    while(j != input.e){
+		input.buf[j % INPUT_BUF] = input.buf[(j+1) % INPUT_BUF];  
+		consputc(input.buf[j+1]);
+		j++;
+	    }
+	    consputc(' ');
+	    /*move cursor back to it's place before shifting*/  
+	    j = input.e;
+	    while(j >= input.x){
+		consputc(LEFTARROW);
+		j--;
+	    }
+	  }
       }
       break;
     default:
       if(c != 0 && input.e-input.r < INPUT_BUF){
         c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
+	/* shift chars if we write in the middle of a line*/
+	if(c != LEFTARROW && c != RIGHTARROW && c != '\n' && c!= BACKSPACE){
+	  uint temp_arrow = input.e;
+	  while(temp_arrow != input.x){
+	      input.buf[temp_arrow % INPUT_BUF] = input.buf[(temp_arrow - 1) % INPUT_BUF];
+	      temp_arrow--;
+	  }
+	  input.buf[input.x++ % INPUT_BUF] = c;
+	  input.e++;
+	}else{
+	  if(c == LEFTARROW)
+	    input.x--;
+	  if(c == RIGHTARROW)
+	    input.x++;
+	  if(c == '\n')
+	    input.buf[input.e++ % INPUT_BUF] = c;
+	    /*input.x = input.e;*/
+	}
         consputc(c);
+	
+	/*shift all chars*/
+	uint i = input.x;
+	  while(i != input.e  && c != '\n' && c != LEFTARROW && c != RIGHTARROW && c != BACKSPACE){
+	      consputc(input.buf[i]);
+	      i++;
+	  }
+	/*move cursor back to it's place before shifting*/  
+	i = input.e;
+	  while(i != input.x  && c != '\n' && c != LEFTARROW && c != RIGHTARROW && c != BACKSPACE){
+	      consputc(LEFTARROW);
+	      i--;
+	  }
+	  
         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+	  input.x = input.e;
           input.w = input.e;
           wakeup(&input.r);
         }
Index: Gsanity.c
===================================================================
--- Gsanity.c	(revision 0)
+++ Gsanity.c	(revision 0)
@@ -0,0 +1,31 @@
+// Test for RR scheduling policy.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+
+void
+grttest(void)
+{
+  int wpid;
+  int i;
+  printf(1, "Father pid is %d\n",getpid());
+  sleep(1000); // maybe suppose to be 10 (linux's manual)
+  fork();
+  for(i = 0; i < 50; i++){
+	printf(1, "process %d is printing for the %d time\n",getpid(),i);
+  }
+  while((wpid = wait())){
+   if(wpid == -1)
+     break;
+   exit();
+  }
+}
+int
+main(void)
+{
+  grttest();
+  exit();
+}

Property changes on: Gsanity.c
___________________________________________________________________
Added: svn:executable
   + *

Index: user.h
===================================================================
--- user.h	(revision 3)
+++ user.h	(working copy)
@@ -22,6 +22,8 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int wait2(int* wtime, int* rtime);
+int nice(void);
 
 // ulib.c
 int stat(char*, struct stat*);
Index: Makefile
===================================================================
--- Makefile	(revision 3)
+++ Makefile	(working copy)
@@ -51,8 +51,8 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-#QEMU = qemu-system-x86_64
-
+QEMU = qemu-system-x86_64
+QEMU = /usr/bin/qemu-system-i386
 # Try to infer the correct QEMU
 ifndef QEMU
 QEMU = $(shell if which qemu > /dev/null; \
@@ -67,13 +67,13 @@
 	echo "***" 1>&2; exit 1)
 endif
 
-CC = $(TOOLPREFIX)gcc
+CC = $(TOOLPREFIX)gcc $(PSCHEDFLAGS)
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer 
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -146,7 +146,7 @@
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
-	gcc -m32 -Werror -Wall -o mkfs mkfs.c
+	gcc -m32 -Werror -Wall -o mkfs mkfs.c 
 
 UPROGS=\
 	_cat\
@@ -164,6 +164,9 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_RRsanity\
+	_Gsanity\
+	_sanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -203,9 +206,22 @@
 CPUS := 1
 endif
 QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
+# SCHEDFLAG macros (macros can't start with digits so we add '_' to each policy)
+# _RR  = 1
+# _FRR = 2
+# _GRT = 3
+# _3Q  = 4
+SCHEDFLAGDEFS := -D _RR=1 -D _FRR=2 -D _GRT=3 -D _3Q=4
+ifdef SCHEDFLAG
+PSCHEDFLAGS := $(SCHEDFLAGDEFS) $(shell echo -D SCHEDFLAG=_)$(SCHEDFLAG)
+endif
+ifndef SCHEDFLAG
+PSCHEDFLAGS := $(SCHEDFLAGDEFS) -D SCHEDFLAG=_RR 
+endif
 
+
 qemu: fs.img xv6.img
-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) 
 
 qemu-memfs: xv6memfs.img
 	$(QEMU) xv6memfs.img -smp $(CPUS)
@@ -232,7 +248,7 @@
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c RRsanity.c Gsanity.c sanity.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
@@ -267,3 +283,4 @@
 	(cd /tmp; tar cf - xv6) | gzip >xv6-rev5.tar.gz
 
 .PHONY: dist-test dist
+
Index: param.h
===================================================================
--- param.h	(revision 3)
+++ param.h	(working copy)
@@ -9,4 +9,5 @@
 #define ROOTDEV       1  // device number of file system root disk
 #define MAXARG       32  // max exec arguments
 #define LOGSIZE      10  // max data sectors in on-disk log
+#define QUANTA        5  // max number of ticks(CPU time) to give a process to run 
 
Index: RRsanity.c
===================================================================
--- RRsanity.c	(revision 0)
+++ RRsanity.c	(revision 0)
@@ -0,0 +1,62 @@
+// Test for RR scheduling policy.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+#define NUM_Of_CHILDREN 10
+
+struct child_stat{
+  int wTime;
+  int rTime;
+  int pid;
+};
+
+void
+rrtest(void)
+{
+  int wTime;
+  int rTime;
+  int tTime;
+  int pid;
+  int wpid;
+  int j;
+  int i;
+  int num_of_forks =NUM_Of_CHILDREN;
+  struct child_stat child_array [NUM_Of_CHILDREN];
+  
+  printf(1, "RRsanity test\n");
+
+    for(j=0; j<num_of_forks; j++){
+	pid = fork();
+	if(pid == 0) break;
+    }
+    
+    if(pid == 0){    
+    for (i=0;i<N;i++){
+	printf(1, "child %d pid prints for the %d time\n",getpid(),i);
+      }
+      exit();
+    }
+   int k = 0;  
+   while ((wpid = wait2(&wTime,&rTime))) {
+   if (wpid == -1) {
+      break;
+      }
+      child_array[k].wTime = wTime;
+      child_array[k].rTime = rTime;
+      child_array[k].pid = wpid;
+      k++;
+   }
+    for(k = 0; k < NUM_Of_CHILDREN; k++){
+      tTime = child_array[k].wTime + child_array[k].rTime;
+      printf(1, "child %d wTime: %d rTime: %d tTime: %d \n",child_array[k].pid,child_array[k].wTime,child_array[k].rTime,tTime);
+    }
+}
+int
+main(void)
+{
+  rrtest();
+  exit();
+}

Property changes on: RRsanity.c
___________________________________________________________________
Added: svn:executable
   + *

Index: sanity.c
===================================================================
--- sanity.c	(revision 0)
+++ sanity.c	(revision 0)
@@ -0,0 +1,176 @@
+// Test for RR scheduling policy.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "limits.h"
+
+#define N  500
+#define NUM_Of_CHILDREN 30
+
+struct child_stat{
+  int wTime;
+  int rTime;
+  int tTime;
+  int pid;
+};
+
+void
+threeqtest(void)
+{
+  int wTime;
+  int rTime;
+  int pid;
+  int wpid;
+  int j;
+  int i;
+  struct child_stat child_array [NUM_Of_CHILDREN];
+  int cid;
+  int sum_wTime;
+  int sum_rTime;
+  int sum_tTime;
+  double avg_wTime;
+  double avg_rTime;
+  double avg_tTime;
+  int first_child = INT_MAX;
+    
+      for(j=0; j<NUM_Of_CHILDREN ; j++){
+	  pid = fork();
+	  cid = j;
+	  if(pid == 0) break;
+      }
+    
+    if(pid == 0){
+	//cid = getpid();
+	//cid = cid - first_child;
+	if((cid % 3) == 0)
+	  nice();
+	if((cid % 3) == 1){
+	  nice();
+	  nice();
+      }  
+      for (i=0;i<N;i++){
+	  printf(1, "child %d pid prints for the %d time\n",cid,i);
+	}
+      exit();
+    }
+   int k = 0;  
+   while ((wpid = wait2(&wTime,&rTime))) {
+   if (wpid == -1) {
+      break;
+      }
+      child_array[k].wTime = wTime;
+      child_array[k].rTime = rTime;
+      child_array[k].tTime = child_array[k].wTime + child_array[k].rTime;
+      child_array[k].pid = wpid;
+      k++;
+   }
+   
+   // find min pid in all children
+   for(k = 0;k< NUM_Of_CHILDREN;k++){
+      if(first_child > child_array[k].pid)
+	first_child = child_array[k].pid;
+   }
+   
+   // decrease first_child from all children to get id's 0-29
+   for(k = 0;k< NUM_Of_CHILDREN;k++){
+      child_array[k].pid = child_array[k].pid - first_child;
+   }
+   
+    for(k = 0; k < NUM_Of_CHILDREN; k++){
+      sum_wTime = sum_wTime + child_array[k].wTime;
+      sum_rTime = sum_rTime + child_array[k].rTime;
+      sum_tTime = sum_tTime + child_array[k].tTime;
+    }
+    avg_wTime = (double)sum_wTime/(double)NUM_Of_CHILDREN;
+    avg_rTime = (double)sum_rTime/(double)NUM_Of_CHILDREN;
+    avg_tTime = (double)sum_tTime/(double)NUM_Of_CHILDREN;
+    printf(1,"---Total Stats---\n");
+    printf(1,"Average waiting time: %d\n",(int)avg_wTime);
+    printf(1,"Average running time: %d\n",(int)avg_rTime);
+    printf(1,"Average turnaround time: %d\n\n",(int)avg_tTime);
+    
+    sum_rTime = 0;
+    sum_tTime = 0;
+    sum_wTime = 0;
+    avg_wTime = 0;
+    avg_rTime = 0;
+    avg_tTime = 0;
+    
+    // print HIGH priority processes
+     for(k = 0; k < NUM_Of_CHILDREN; k++){
+      if((child_array[k].pid % 3) == 2) {
+	sum_wTime = sum_wTime + child_array[k].wTime;
+	sum_rTime = sum_rTime + child_array[k].rTime;
+	sum_tTime = sum_tTime + child_array[k].tTime;
+      }
+    }
+    
+    avg_wTime = (double)sum_wTime/(NUM_Of_CHILDREN / 3);
+    avg_rTime = (double)sum_rTime/(NUM_Of_CHILDREN / 3);
+    avg_tTime = (double)sum_tTime/(NUM_Of_CHILDREN / 3);
+    printf(1,"---Group High Priority Stats---\n");
+    printf(1,"Average waiting time: %d\n",(int)avg_wTime);
+    printf(1,"Average running time: %d\n",(int)avg_rTime);
+    printf(1,"Average turnaround time: %d\n\n",(int)avg_tTime);
+    
+    sum_rTime = 0;
+    sum_tTime = 0;
+    sum_wTime = 0;
+    avg_wTime = 0;
+    avg_rTime = 0;
+    avg_tTime = 0;
+    
+     // print MEDIUM priority processes
+     for(k = 0; k < NUM_Of_CHILDREN; k++){
+      if((child_array[k].pid % 3) == 0){
+	sum_wTime = sum_wTime + child_array[k].wTime;
+	sum_rTime = sum_rTime + child_array[k].rTime;
+	sum_tTime = sum_tTime + child_array[k].tTime;
+      }
+    }
+    
+    avg_wTime = (double)sum_wTime/(NUM_Of_CHILDREN / 3);
+    avg_rTime = (double)sum_rTime/(NUM_Of_CHILDREN / 3);
+    avg_tTime = (double)sum_tTime/(NUM_Of_CHILDREN / 3);
+    printf(1,"---Group Medium Priority Stats---\n");
+    printf(1,"Average waiting time: %d\n",(int)avg_wTime);
+    printf(1,"Average running time: %d\n",(int)avg_rTime);
+    printf(1,"Average turnaround time: %d\n\n",(int)avg_tTime);
+    
+    sum_rTime = 0;
+    sum_tTime = 0;
+    sum_wTime = 0;
+    avg_wTime = 0;
+    avg_rTime = 0;
+    avg_tTime = 0;
+    
+     // print LOW priority processes
+     for(k = 0; k < NUM_Of_CHILDREN; k++){
+      if((child_array[k].pid % 3) == 1) {
+	sum_wTime = sum_wTime + child_array[k].wTime;
+	sum_rTime = sum_rTime + child_array[k].rTime;
+	sum_tTime = sum_tTime + child_array[k].tTime;
+      }
+    }
+    
+    avg_wTime = (double)sum_wTime/(NUM_Of_CHILDREN / 3);
+    avg_rTime = (double)sum_rTime/(NUM_Of_CHILDREN / 3);
+    avg_tTime = (double)sum_tTime/(NUM_Of_CHILDREN / 3);
+    printf(1,"---Group Low Priority Stats---\n");
+    printf(1,"Average waiting time: %d\n",(int)avg_wTime);
+    printf(1,"Average running time: %d\n",(int)avg_rTime);
+    printf(1,"Average turnaround time: %d\n\n",(int)avg_tTime);
+    
+    // print each child stats
+    printf(1,"---Each Child Stats---\n");
+    for (k=0;k<NUM_Of_CHILDREN;k++){
+      printf(1, "child %d wTime: %d rTime: %d tTime: %d \n",child_array[k].pid,child_array[k].wTime,child_array[k].rTime,child_array[k].tTime);
+    }
+}
+int
+main(void)
+{
+  threeqtest();
+  exit();
+}
\ No newline at end of file

Property changes on: sanity.c
___________________________________________________________________
Added: svn:executable
   + *

Index: sh.c
===================================================================
--- sh.c	(revision 3)
+++ sh.c	(working copy)
@@ -1,494 +1,550 @@
-// Shell.
-
-#include "types.h"
-#include "user.h"
-#include "fcntl.h"
-
-// Parsed command representation
-#define EXEC  1
-#define REDIR 2
-#define PIPE  3
-#define LIST  4
-#define BACK  5
-
-#define MAXARGS 10
-
-struct cmd {
-  int type;
-};
-
-struct execcmd {
-  int type;
-  char *argv[MAXARGS];
-  char *eargv[MAXARGS];
-};
-
-struct redircmd {
-  int type;
-  struct cmd *cmd;
-  char *file;
-  char *efile;
-  int mode;
-  int fd;
-};
-
-struct pipecmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct listcmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct backcmd {
-  int type;
-  struct cmd *cmd;
-};
-
-int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
-
-// Execute cmd.  Never returns.
-void
-runcmd(struct cmd *cmd)
-{
-  int p[2];
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    exit();
-  
-  switch(cmd->type){
-  default:
-    panic("runcmd");
-
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
-      exit();
-    exec(ecmd->argv[0], ecmd->argv);
-    printf(2, "exec %s failed\n", ecmd->argv[0]);
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
-      printf(2, "open %s failed\n", rcmd->file);
-      exit();
-    }
-    runcmd(rcmd->cmd);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(lcmd->left);
-    wait();
-    runcmd(lcmd->right);
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
-      panic("pipe");
-    if(fork1() == 0){
-      close(1);
-      dup(p[1]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->left);
-    }
-    if(fork1() == 0){
-      close(0);
-      dup(p[0]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->right);
-    }
-    close(p[0]);
-    close(p[1]);
-    wait();
-    wait();
-    break;
-    
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(bcmd->cmd);
-    break;
-  }
-  exit();
-}
-
-int
-getcmd(char *buf, int nbuf)
-{
-  printf(2, "$ ");
-  memset(buf, 0, nbuf);
-  gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
-    return -1;
-  return 0;
-}
-
-int
-main(void)
-{
-  static char buf[100];
-  int fd;
-  
-  // Assumes three file descriptors open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
-      close(fd);
-      break;
-    }
-  }
-  
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Clumsy but will have to do for now.
-      // Chdir has no effect on the parent if run in the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
-      continue;
-    }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
-}
-
-void
-panic(char *s)
-{
-  printf(2, "%s\n", s);
-  exit();
-}
-
-int
-fork1(void)
-{
-  int pid;
-  
-  pid = fork();
-  if(pid == -1)
-    panic("fork");
-  return pid;
-}
-
-//PAGEBREAK!
-// Constructors
-
-struct cmd*
-execcmd(void)
-{
-  struct execcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = EXEC;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
-  struct redircmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = REDIR;
-  cmd->cmd = subcmd;
-  cmd->file = file;
-  cmd->efile = efile;
-  cmd->mode = mode;
-  cmd->fd = fd;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
-  struct pipecmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = PIPE;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
-  struct listcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = LIST;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
-  struct backcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = BACK;
-  cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
-}
-//PAGEBREAK!
-// Parsing
-
-char whitespace[] = " \t\r\n\v";
-char symbols[] = "<|>&;()";
-
-int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
-  char *s;
-  int ret;
-  
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  if(q)
-    *q = s;
-  ret = *s;
-  switch(*s){
-  case 0:
-    break;
-  case '|':
-  case '(':
-  case ')':
-  case ';':
-  case '&':
-  case '<':
-    s++;
-    break;
-  case '>':
-    s++;
-    if(*s == '>'){
-      ret = '+';
-      s++;
-    }
-    break;
-  default:
-    ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-      s++;
-    break;
-  }
-  if(eq)
-    *eq = s;
-  
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return ret;
-}
-
-int
-peek(char **ps, char *es, char *toks)
-{
-  char *s;
-  
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return *s && strchr(toks, *s);
-}
-
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
-
-struct cmd*
-parsecmd(char *s)
-{
-  char *es;
-  struct cmd *cmd;
-
-  es = s + strlen(s);
-  cmd = parseline(&s, es);
-  peek(&s, es, "");
-  if(s != es){
-    printf(2, "leftovers: %s\n", s);
-    panic("syntax");
-  }
-  nulterminate(cmd);
-  return cmd;
-}
-
-struct cmd*
-parseline(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
-    gettoken(ps, es, 0, 0);
-    cmd = backcmd(cmd);
-  }
-  if(peek(ps, es, ";")){
-    gettoken(ps, es, 0, 0);
-    cmd = listcmd(cmd, parseline(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parsepipe(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
-    gettoken(ps, es, 0, 0);
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
-  int tok;
-  char *q, *eq;
-
-  while(peek(ps, es, "<>")){
-    tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
-      panic("missing file for redirection");
-    switch(tok){
-    case '<':
-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
-      break;
-    case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    }
-  }
-  return cmd;
-}
-
-struct cmd*
-parseblock(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  if(!peek(ps, es, "("))
-    panic("parseblock");
-  gettoken(ps, es, 0, 0);
-  cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
-    panic("syntax - missing )");
-  gettoken(ps, es, 0, 0);
-  cmd = parseredirs(cmd, ps, es);
-  return cmd;
-}
-
-struct cmd*
-parseexec(char **ps, char *es)
-{
-  char *q, *eq;
-  int tok, argc;
-  struct execcmd *cmd;
-  struct cmd *ret;
-  
-  if(peek(ps, es, "("))
-    return parseblock(ps, es);
-
-  ret = execcmd();
-  cmd = (struct execcmd*)ret;
-
-  argc = 0;
-  ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
-      break;
-    if(tok != 'a')
-      panic("syntax");
-    cmd->argv[argc] = q;
-    cmd->eargv[argc] = eq;
-    argc++;
-    if(argc >= MAXARGS)
-      panic("too many args");
-    ret = parseredirs(ret, ps, es);
-  }
-  cmd->argv[argc] = 0;
-  cmd->eargv[argc] = 0;
-  return ret;
-}
-
-// NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
-  int i;
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    return 0;
-  
-  switch(cmd->type){
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
-      *ecmd->eargv[i] = 0;
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    nulterminate(rcmd->cmd);
-    *rcmd->efile = 0;
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    nulterminate(pcmd->left);
-    nulterminate(pcmd->right);
-    break;
-    
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    nulterminate(lcmd->left);
-    nulterminate(lcmd->right);
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    nulterminate(bcmd->cmd);
-    break;
-  }
-  return cmd;
-}
+// Shell.
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+
+// Parsed command representation
+#define EXEC  1
+#define REDIR 2
+#define PIPE  3
+#define LIST  4
+#define BACK  5
+
+#define MAXARGS 10
+
+char* PATH[100];
+
+struct cmd {
+  int type;
+};
+
+struct execcmd {
+  int type;
+  char *argv[MAXARGS];
+  char *eargv[MAXARGS];
+};
+// 
+struct redircmd {
+  int type;
+  struct cmd *cmd;
+  char *file;
+  char *efile;
+  int mode;
+  int fd;
+};
+
+struct pipecmd {
+  int type;
+  struct cmd *left;
+  struct cmd *right;
+};
+
+struct listcmd {
+  int type;
+  struct cmd *left;
+  struct cmd *right;
+};
+
+struct backcmd {
+  int type;
+  struct cmd *cmd;
+};
+
+int fork1(void);  // Fork but panics on failure.
+void panic(char*);
+struct cmd *parsecmd(char*);
+
+// Execute cmd.  Never returns.
+void
+runcmd(struct cmd *cmd)
+{
+  int p[2];
+  struct backcmd *bcmd;
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  
+  
+  if(cmd == 0)
+    exit();
+  
+  switch(cmd->type){
+  default:
+    panic("runcmd");
+
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    if(ecmd->argv[0] == 0){
+      exit();
+    }
+      exec(ecmd->argv[0], ecmd->argv);//try exec normally
+   
+      //#######we did######
+      //try the other paths
+    int i = 0;
+    int j = 0;
+    char temp_path[100];
+    
+   
+    while(PATH[i]){
+     strcpy(temp_path,PATH[i]);//copy the new path
+     int path_length = strlen(PATH[i]);//gets the length of the next path
+     for(j = 0; j <= strlen(ecmd->argv[j]) ; j++){//copy the arguments
+       temp_path[path_length+j] = ecmd->argv[0][j];
+     }
+     exec(temp_path,ecmd->argv);
+     i++;
+    }
+   //#######changes ending######
+    
+    //print in case of failure
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+    break;
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+    close(rcmd->fd);
+    if(open(rcmd->file, rcmd->mode) < 0){
+      printf(2, "open %s failed\n", rcmd->file);
+      exit();
+    }
+    runcmd(rcmd->cmd);
+    break;
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    if(fork1() == 0)
+      runcmd(lcmd->left);
+    wait();
+    runcmd(lcmd->right);
+    break;
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+    if(pipe(p) < 0)
+      panic("pipe");
+    if(fork1() == 0){
+      close(1);
+      dup(p[1]);
+      close(p[0]);
+      close(p[1]);
+      runcmd(pcmd->left);
+    }
+    if(fork1() == 0){
+      close(0);
+      dup(p[0]);
+      close(p[0]);
+      close(p[1]);
+      runcmd(pcmd->right);
+    }
+    close(p[0]);
+    close(p[1]);
+    wait();
+    wait();
+    break;
+    
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+    if(fork1() == 0)
+      runcmd(bcmd->cmd);
+    break;
+  
+  }
+  exit();
+}
+
+int
+getcmd(char *buf, int nbuf)//read the cmd to memory and return a pointer to the memory
+{
+  printf(2, "$ ");//print the $ at the begining
+  memset(buf, 0, nbuf);//fills the first "nbuf" bytes of the memory area pointed to by "buf" with the constant byte 0->initialize 0 at the cmd []
+  gets(buf, nbuf);//reads a line from stdin into the buffer pointed to by s until null
+  if(buf[0] == 0) // EOF
+    return -1;
+  return 0;
+}
+//####our function####
+void
+readPath(char* paths)//read the pathes and update the PATH varible;
+{
+ //printf(2, "readPath \n");
+  int i=0;//pointer on the paths, starts at 12 where the pathes starts
+  int path_end;//place of the end of a specific path
+  char* temp_path;//a temp path
+  
+  for(i=0;;i++){
+    temp_path =strchr(paths,':');//find the next ':' in paths
+    if(!temp_path) break;//we reached the end of the pathes
+    else {
+      path_end = strlen(paths) - strlen(temp_path);//find the begining of the path
+      PATH[i] = (char*)malloc(strlen(paths)*sizeof(char));//allocate the memory for the i path
+      strcpy(PATH[i],paths);//copy the i path to the PATH variable 
+      PATH[i][path_end]='\0';//make the path end with '\0'
+      paths = temp_path + 1; //move to next path by deleting the first path;
+    }
+  }
+ PATH[i+1] = '\0'; // end the new PATH with '\0'
+  
+}
+ 
+int
+main(void)
+{
+  static char buf[100];
+  int fd;
+  
+  // Assumes three file descriptors open.
+  //open file descriptors
+  while((fd = open("console", O_RDWR)) >= 0){
+    if(fd >= 3){
+      close(fd);
+      break;
+    }
+  }
+  
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+      if(chdir(buf+3) < 0)
+        printf(2, "cannot cd %s\n", buf+3);
+      continue;
+    }
+    //check for export method
+    else if(buf[0]=='e' && buf[1]=='x'&& buf[2]=='p'&& buf[3]=='o'&& buf[4]=='r'&& buf[5]=='t'){//export PATH
+    buf[strlen(buf)-1] =0;
+    readPath(buf+12);//our function for prasing the paths
+    continue;
+    }
+    if(fork1() == 0)
+      runcmd(parsecmd(buf));//send the child to do whatever return from the parsecmd(buf)
+    wait();
+  }
+  exit();
+}
+
+
+void
+panic(char *s)//print the *s it gets
+{
+  printf(2, "%s\n", s);
+  exit();
+}
+
+int
+fork1(void)
+{
+  int pid;
+  
+  pid = fork();
+  if(pid == -1)
+    panic("fork");
+  return pid;
+}
+
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = EXEC;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = REDIR;
+  cmd->cmd = subcmd;
+  cmd->file = file;
+  cmd->efile = efile;
+  cmd->mode = mode;
+  cmd->fd = fd;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = PIPE;
+  cmd->left = left;
+  cmd->right = right;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = LIST;
+  cmd->left = left;
+  cmd->right = right;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = BACK;
+  cmd->cmd = subcmd;
+   return (struct cmd*)cmd;
+}
+//PAGEBREAK!
+// Parsing
+
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+  char *s;
+  int ret;
+  
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))
+    s++;
+  if(q)
+    *q = s;
+  ret = *s;
+  switch(*s){
+  case 0:
+    break;
+  case '|':
+  case '(':
+  case ')':
+  case ';':
+  case '&':
+  case '<':
+    s++;
+    break;
+  case '>':
+    s++;
+    if(*s == '>'){
+      ret = '+';
+      s++;
+    }
+    break;
+  default:
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+  }
+  if(eq)
+    *eq = s;
+  
+  while(s < es && strchr(whitespace, *s))
+    s++;
+  *ps = s;
+  return ret;
+}
+
+int
+peek(char **ps, char *es, char *toks)//get the begining and ending adress and some tokns
+{
+  char *s;
+  
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))//looking for the first apperns of \t\r\n\v
+    s++;
+  *ps = s;
+  return *s && strchr(toks, *s);//check that we have somthing to do beside \t\r\n\v
+}
+
+struct cmd *parseline(char**, char*);
+struct cmd *parsepipe(char**, char*);
+struct cmd *parseexec(char**, char*);
+struct cmd *nulterminate(struct cmd*);
+
+struct cmd*
+parsecmd(char *s)//get Char*
+{
+  char *es;
+  struct cmd *cmd;
+
+  es = s + strlen(s);//go to the end of s in memory
+  cmd = parseline(&s, es);//send the begining and ending adress of the input
+  peek(&s, es, "");
+  if(s != es){
+    printf(2, "leftovers: %s\n", s);
+    panic("syntax");
+  }
+  nulterminate(cmd);
+  return cmd;
+}
+
+struct cmd*
+parseline(char **ps, char *es)//get the begining and the end of the input
+{
+  struct cmd *cmd;
+
+  cmd = parsepipe(ps, es);////check the input syntax
+  while(peek(ps, es, "&")){
+    gettoken(ps, es, 0, 0);
+    cmd = backcmd(cmd);
+  }
+  if(peek(ps, es, ";")){
+    gettoken(ps, es, 0, 0);
+    cmd = listcmd(cmd, parseline(ps, es));
+  }
+  return cmd;
+}
+
+struct cmd*
+parsepipe(char **ps, char *es)//get the begining and ending of the input
+{
+  struct cmd *cmd;
+
+  cmd = parseexec(ps, es);//get the bgining and ending of the input
+  if(peek(ps, es, "|")){
+    gettoken(ps, es, 0, 0);
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+  }
+  return cmd;
+}
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+    tok = gettoken(ps, es, 0, 0);
+    if(gettoken(ps, es, &q, &eq) != 'a')
+      panic("missing file for redirection");
+    switch(tok){
+    case '<':
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+      break;
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    }
+  }
+  return cmd;
+}
+
+struct cmd*
+parseblock(char **ps, char *es)
+{
+  struct cmd *cmd;
+
+  if(!peek(ps, es, "("))
+    panic("parseblock");
+  gettoken(ps, es, 0, 0);
+  cmd = parseline(ps, es);
+  if(!peek(ps, es, ")"))
+    panic("syntax - missing )");
+  gettoken(ps, es, 0, 0);
+  cmd = parseredirs(cmd, ps, es);
+  return cmd;
+}
+
+struct cmd*
+parseexec(char **ps, char *es)//check the input syntax and exec
+{
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+  
+  if(peek(ps, es, "("))//type of "(foo)" commned
+    return parseblock(ps, es);
+
+  ret = execcmd();
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+  while(!peek(ps, es, "|)&;")){
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+      break;
+    if(tok != 'a')//check the syntax some how
+      panic("syntax");
+    cmd->argv[argc] = q;
+    cmd->eargv[argc] = eq;
+    argc++;
+    if(argc >= MAXARGS)//check the namber of arguments
+      panic("too many args");
+    ret = parseredirs(ret, ps, es);
+  }
+  cmd->argv[argc] = 0;
+  cmd->eargv[argc] = 0;
+  return ret;
+}
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+  int i;
+  struct backcmd *bcmd;
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+    return 0;
+  
+  switch(cmd->type){
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    for(i=0; ecmd->argv[i]; i++)
+      *ecmd->eargv[i] = 0;
+    break;
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+    nulterminate(rcmd->cmd);
+    *rcmd->efile = 0;
+    break;
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+    nulterminate(pcmd->left);
+    nulterminate(pcmd->right);
+    break;
+    
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    nulterminate(lcmd->left);
+    nulterminate(lcmd->right);
+    break;
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+    nulterminate(bcmd->cmd);
+    break;
+  }
+  return cmd;
+}
\ No newline at end of file
Index: syscall.c
===================================================================
--- syscall.c	(revision 3)
+++ syscall.c	(working copy)
@@ -98,6 +98,8 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_wait2(void);
+extern int sys_nice(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +123,8 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_wait2]   sys_wait2,
+[SYS_nice]    sys_nice,
 };
 
 void
Index: syscall.h
===================================================================
--- syscall.h	(revision 3)
+++ syscall.h	(working copy)
@@ -21,3 +21,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+#define SYS_wait2  22
+#define SYS_nice   23
\ No newline at end of file
Index: usys.S
===================================================================
--- usys.S	(revision 3)
+++ usys.S	(working copy)
@@ -29,3 +29,5 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(wait2)
+SYSCALL(nice)
